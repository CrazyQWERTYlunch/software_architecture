# Урок 1. Введение в понятие архитектуры, проектирование ПО и жизненный цикл программного продукта. UML-диаграммы
## ЗАДАНИЕ:
> 1. **На основе Диаграмы классов ModelElements, разработать классы: Model Store, PoligonalModel (Texture, Poligon), Flash, Camera, Scene (Реализовать диограмму на любом языке программирования)**
> 2. **Ознакомиться с документацией:**
> - ГОСТ Р ИСО/МЭК 12207-2010 Информационная технология (ИТ). Системная и программная инженерия. Процессы жизненного цикла программных средств.
> - ISO/IEC/IEEE 29148:2018 Systems and software engineering — Life cycle processes — Requirements engineering
> - Стандарты ЕСКД — единая система конструкторской документации
> - ГОСТ 2.001-2013 ЕСКД. Общие положения
> - Стандарты АСУ ГОСТ 34 — автоматизированные системы управления
> - Стандарты ЕСПД ГОСТ 19 — единая система программной документации

# Урок 2. Объектно-ориентированные паттерны
## ЗАДАНИЕ:
> **Прислать простую реализацию 5-ти Патернов ,на любом языке (С комментариями ), из списка:** 
1. Строитель (Builder)
2. Цепочка обязанностей (Chain of Responsibility)
3. Команда (Command)
4. Итератор (Iterator)
5. Посредник (Mediator)
6. Памятка (Memento)
7. Состояние (State)
8. Стратегия (Strategy)
9. Шаблонный метод (Template Method)
10. Посетитель (Visitor)

# Урок 3. Принципы SOLID
## ЗАДАНИЕ:
> **Продолжить работу с семинара.**
> 1. Hассмотрим четвертый принцип SOLID - Принцип сегрегации интерфейса (Interface Segregation Principle, ISP). Он гласит: "Клиенты не должны зависеть от интерфейсов, которые они не используют".
> Вам надо написать код который исправяет эту ошибку и реализует этот принцип
> 2. Принцип инверсии зависимостей (Dependency Inversion Principle, DIP) гласит: "Зависимости на абстракциях. Нет зависимостей на что-то конкретное". Это означает, что высокоуровневые модули, которые обеспечивают сложную логику, должны быть независимы от низкоуровневых модулей, которые обеспечивают утилитарные функции. Оба типа модулей должны зависеть от абстракций. 

# Урок 4. Компоненты. Принципы связности и сочетаемости компонентов
## ЗАДАНИЕ: 
> **Необходимо доработать код, добавив контракты к методам, документацию и обеспечив высокую связанность и низкую сочетаемость**

# Урок 5. Горизонтальные уровни и вертикальные срезы арзитектуры
## ЗАДАНИЕ:
> **Реализовать любой паттерн с лекции . Выпустить диаграмму компонент UML по нему**

# Урок 6. Принципы построения приложений «чистая архитектура»
## ЗАДАНИЕ:
> Переделка программы под чистую архитектуру
> Вам предоставляется программа, которая представляет интернет-магазин книг с использованием коллекций. Ваша задача - переработать эту  программу, применяя принципы чистой архитектуры для лучшей организации кода и разделения компонентов. В результате переработки программа должна следовать принципам Boundary-Control-Entity (BCE).
> Требования:
> Создайте пакеты domain, data, и presentation.
> В пакете domain создайте классы, представляющие бизнес-объекты интернет-магазина книг. Например, Book - представляющий модель книги.
> В пакете data создайте интерфейс BookRepository, определяющий методы для управления книгами в интернет-магазине. Затем реализуйте этот интерфейс в классе InMemoryBookRepository, используя коллекции для хранения данных о книгах.
> В пакете presentation создайте класс Main, который будет представлять точку входа в приложение и обрабатывать пользовательские запросы.
> Используйте принципы чистой архитектуры для организации компонентов (BCE). Каждый компонент должен быть отделен от других, взаимодействие должно происходить через абстракции, а не через конкретные реализации.
> Перенесите функциональность работы с коллекциями и хранения данных в пакет data, таким образом, чтобы она не проникала в другие компоненты.
> Обеспечьте возможность добавления, удаления и получения списка книг через интерфейс BookRepository, а затем используйте его в Main для управления книгами.
> Убедитесь, что код программы чистый, читаемый и хорошо структурированный. Обеспечьте надлежащее разделение ответственности между компонентами и минимизируйте повторяющийся код.

# Урок 7. Типа архитектур WEB-приложений: MPA, SPA.
## ЗАДАНИЕ:
> 1 - Описать этот этап по примеру ниже , выбрать любую тему для веб приложение.
> 2 - Пункт 1.7 - необходимо сделать сырой пример страницы , прислать скриншот любой страницы (https://www.figma.com или воспользоваться другим инструментом ), то есть физичекси указать примерные цвета , расположение кнопок и т д. . можно взять за основу мобильную версию , т к ее проще делать . ( Вы не дизайнеры , но дизайнер дорден понять Вашу мысль, чтобы сдедать красило по шаблону )

# Урок 8. Типы архитектур прикладных приложений (мобильные): MVC, MVP, MVVM.
## ЗАДАНИЕ:
> Задание: Создание UML диаграммы классов для веб-приложения(Любого, но лучше взять за основу прошлую работу)
# Урок 9. Способы организации передачи данных между компонентами приложения, протоколы и API. REST, gRPC, очереди
## Задание:
> Домашнее задание: Разработка и тестирование RESTful API на Python
# Урок 10. Структура приложения с пользовательским интерфейсом и базой данных (паттерн Repository)
> **Часть 1: Паттерн Агрегатор**
> Реализуйте классы Order, OrderItem и Product.
> Order должен содержать список OrderItem, каждый из которых содержит Product и количество этого продукта.
> У каждого заказа должен быть метод для расчета общей стоимости.
> **Часть 2: Паттерн Репозиторий**
> Создайте интерфейс OrderRepository, который определяет методы для работы с заказами (сохранение, загрузка по ID, загрузка всех заказов и т. д.).
> Реализуйте класс OrderRepositoryImpl, который реализует данный интерфейс, используя любую базу данных на ваш выбор (может быть встроенной, например, SQLite).
> В репозитории обеспечьте сохранение и загрузку заказов, а также всех связанных с ними объектов (OrderItem, Product).
> **Часть 3: Паттерн Кеширования**
> Исследуйте и выберите одну из библиотек для кеширования в Java (например, EhCache, Caffeine или Guava Cache).
> Реализуйте кеширование в вашем репозитории таким образом, чтобы часто запрашиваемые заказы загружались из кэша, а не из базы данных.
> Обеспечьте инвалидацию кэша (обновление данных в кэше), если информация в базе данных была изменена.
